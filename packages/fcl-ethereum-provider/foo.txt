import {
  EthereumProvider,
  EthereumProviderOptions,
} from "@walletconnect/ethereum-provider"
import {createProvider, FclProviderConfig} from "./create-provider"
import {
  Eip1193Provider,
  ProviderRequest,
  ProviderResponse,
} from "./types/provider"
import {Service} from "@onflow/typedefs"
import {
  NamespaceConfig,
  UniversalProvider,
} from "@walletconnect/universal-provider"
import {SessionTypes} from "@walletconnect/types"
import {NetworkManager} from "./network/network-manager"
import {FLOW_CHAINS, FlowNetwork} from "./constants"
import {bytesToHex} from "@noble/hashes/utils"
import {formatChainId} from "./util/eth"
import {getAccountsFromNamespaces} from "@walletconnect/utils"

type Options = EthereumProviderOptions & Omit<FclProviderConfig, "service">

const BASE_WC_SERVICE = {
  f_type: "Service",
  f_vsn: "1.0.0",
  type: "authn",
  method: "WC/RPC",
  uid: "https://walletconnect.com",
  endpoint: "flow_authn",
  optIn: true,
  provider: {
    address: null,
    name: "WalletConnect",
    icon: "https://avatars.githubusercontent.com/u/37784886",
    description: "WalletConnect Base Service",
    website: "https://walletconnect.com",
    color: null,
    supportEmail: null,
  },
} as unknown as Service

/**
 * This is a Universal WalletConnect provider for the Flow blockchain designed for cross-VM compatibility.
 * It is a wrapper around the EthereumProvider and the FCL provider, where wallets with Cadence compatibility
 * will be compatible with both Cadence/EVM and EVM-native wallets will fallback to the Ethereum provider.
 * @param options
 * @returns
 */
export function createWcProvider(options: Options): Eip1193Provider {
  const networkManager = new NetworkManager(options.config)

  networkManager.$chainId.subscribe

  class ExtendedEthereumProvider extends EthereumProvider {
    async connect(
      opts?: Parameters<InstanceType<typeof EthereumProvider>["connect"]>[0]
    ) {
      if (!this.signer.client) {
        throw new Error("Provider not initialized. Call init() first")
      }

      this.loadConnectOpts(opts)
      const {required, optional} = buildNamespaces(FlowNetwork.MAINNET)
      try {
        const session = await new Promise<SessionTypes.Struct | undefined>(
          async (resolve, reject) => {
            if (this.rpc.showQrModal) {
              this.modal?.subscribeModal((state: {open: boolean}) => {
                // the modal was closed so reject the promise
                if (!state.open && !this.signer.session) {
                  this.signer.abortPairingAttempt()
                  reject(
                    new Error("Connection request reset. Please try again.")
                  )
                }
              })
            }
            await this.signer
              .connect({
                namespaces: required,
                optionalNamespaces: optional,
                pairingTopic: opts?.pairingTopic,
              })
              .then((session?: SessionTypes.Struct) => {
                resolve(session)
              })
              .catch((error: Error) => {
                reject(new Error(error.message))
              })
          }
        )
        if (!session) return

        const accounts = getAccountsFromNamespaces(session.namespaces, [
          this.namespace,
        ])
        // if no required chains are set, use the approved accounts to fetch chainIds
        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts)
        this.setAccounts(accounts)
        this.events.emit("connect", {chainId: formatChainId(this.chainId)})
      } catch (error) {
        this.signer.logger.error(error)
        throw error
      } finally {
        if (this.modal) this.modal.closeModal()
      }
    }
  }

  // We centrally manage the WalletConnect session here
  // and pass it into the domain-specific providers
  const provider = new UniversalProvider({})

  const ethProvider = new ExtendedEthereumProvider()
  const fclProvider = createProvider({
    user: options.user,
    config: options.config,
    service: BASE_WC_SERVICE,
    gateway: options.gateway,
    rpcUrls: options.rpcUrls,
  })

  async function authenticate() {
    // TODO fill out namespaces
    const session = await provider.connect({
      optionalNamespaces: {},
    })
    if (session == null) {
      throw new Error("Failed to connect to WalletConnect")
    }

    //
    session.namespaces

    const accounts = await ethProvider.connect({})
    // If the wallet is not FCL-compatible, we fallback to the Ethereum provider
    return accounts

    /* TODO, you need to fallback for wallets that are not EVM-compatible
    // Check if the wallet is FCL-compatible
    for (const namespace in ethProvider.signer.session?.namespaces) {
        if (namespace === "flow") {
          return ethProvider.signer.session
        }
      }*/
  }

  function hasFclSession() {
    return ethProvider.signer.session != null
  }

  return {
    on(event, listener) {
      ethProvider.on(event, listener)
      fclProvider.on(event, listener)
    },
    removeListener(event, listener) {
      ethProvider.removeListener(event, listener)
      fclProvider.removeListener(event, listener)
    },
    async disconnect() {
      await Promise.all([ethProvider.disconnect(), fclProvider.disconnect()])
    },
    async enable() {
      return authenticate()
    },
    async request<T = unknown>(
      args: ProviderRequest
    ): Promise<ProviderResponse<T>> {},
    async connect(opts?: ConnectOps): Promise<void> {},
  }
}

function buildNamespaces(network: FlowNetwork): {
  required: NamespaceConfig
  optional: NamespaceConfig
} {
  const {eip155ChainId} = FLOW_CHAINS[network]

  return {
    required: {
      eip155: {
        methods: ["eth_sendTransaction", "eth_signTypedData"],
        chains: [`eip155:${eip155ChainId}`],
        events: ["chainChanged", "accountsChanged"],
      },
    },
    optional: {
      flow: {
        methods: ["eth_sendTransaction", "eth_signTypedData"],
        events: ["chainChanged", "accountsChanged"],
        chains: [`flow:${network}`],
      },
    },
  }
}
